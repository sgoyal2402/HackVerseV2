{% extends 'base.html' %}
{% load static %}
{% block body %}


<div class="jumbotron jumbotron-fluid"
    style="background-image: url({% static 'img/jumbo.png' %}); background-size: cover;">
    <div class=" container">
        <h1 class="display-4 pt-5" style="text-align: center;">Process Scheduling</h1>
    </div>
</div>

  <!-- About Section -->
    <div class="container">

            <h2 class="w3-center" style="text-align: center;"><strong>About Process Scheduling</strong></h1><br>
            <p class="w3-large">The <b>process scheduling</b> is the activity of the process manager that handles the removal of the running process from the CPU and the selection of another process on the basis of a particular strategy.<br>
                                Process scheduling is an essential part of a Multiprogramming operating systems. Such operating systems allow more than one process to be loaded into the executable memory at a time and the loaded process shares the CPU using time multiplexing.</p>
            <p class="w3-large w3-text-grey w3-hide-medium">A Process Scheduler schedules different processes to be assigned to the CPU based on particular scheduling algorithms. There are 5 popular process scheduling algorithms which we are going to discuss are :<br><br>
                                                            1.First-Come, First-Served (FCFS) Scheduling<br>
                                                            2.Shortest-Job-Next (SJN) Scheduling<br>
                                                            3.Priority Scheduling<br>
                                                            4.Shortest Remaining Time<br>
                                                            5.Round Robin(RR) Scheduling<br></p>
            <p class="w3-large">These algorithms are either non-preemptive or preemptive. Non-preemptive algorithms are designed so that once a process enters the running state, it cannot be preempted until it completes its allotted time,
                                whereas the preemptive scheduling is based on priority where a scheduler may preempt a low priority running process anytime when a high priority process enters into a ready state.</p>
    </div>
    <br>

  <!-- Menu Section -->
    <div class="container">
        <div class="w3-col l6 w3-padding-large">
            <h2 class="w3-center" style="text-align: center;"><strong>Types</strong></h2><br>
            <h4>First Come First Serve (FCFS)</h4>
            <p class="w3-text-grey">Jobs are executed on first come, first serve basis. It is a non-preemptive/preemptive scheduling algorithm. It is quite easy to understand and implement;
                                    implementation is based on FIFO queue. However it is poor in terms of performance as average wait time is high.</p><br>

            <h4>Shortest Job Next (SJN)</h4>
            <p class="w3-text-grey">This is also known as shortest job first, or SJF. This is a non-preemptive/preemptive scheduling algorithm. It is the best approach to minimize waiting time.
                                    It is quite easy to implement in batch systems where required CPU time is known in advance but it is impossible to implement in interactive systems where required CPU time is not known as the processor should know in advance how much time process will take.</p><br>

            <h4>Priority Based Scheduling</h4>
            <p class="w3-text-grey">Priority scheduling is a non-preemptive algorithm and one of the most common scheduling algorithms in batch systems. Each process is assigned a priority. Process with highest priority is to be executed first and so on.
                                    Processes with same priority are executed on first come first served basis. Priority can be decided based on memory requirements, time requirements or any other resource requirement.<br>
                                    In priority-based scheduling algorithms, a major problem is indefinite block, or starvation. A process that is ready to run but waiting for the CPU can be considered blocked. A priority scheduling algorithm can leave some low-priority processes waiting indefinitely.
                                    A steady stream of higher-priority processes can prevent a low-priority process from ever getting the CPU.<br>
                                    Aging is used to ensure that jobs with lower priority will eventually complete their execution. This technique can be used to reduce starvation of low priority tasks. There are many ways to implement aging, but all have the same principle that the priority of a process should increase as it waits in the ready queue.
                                    The increase in priority may or may not be equal to the waiting time of the process.</p><br>

            <h4>Shortest Remaining Time First (SRTF)</h4>
            <p class="w3-text-grey">Shortest remaining time (SRT) is the preemptive version of the SJN algorithm. The processor is allocated to the job closest to completion but it can be preempted by a newer ready job with shorter time to completion.
                                    Once again it is impossible to implement in interactive systems where required CPU time is not known. It is often used in batch environments where short jobs need to give preference.</p><br>

            <h4>Round Robin Scheduling (RR)</h4>
            <p class="w3-text-grey">Round Robin scheduling algorithm is one of the most popular scheduling algorithm which can actually be implemented in most of the operating systems. This is the preemptive version of first come first serve scheduling. The Algorithm focuses on Time Sharing. In this algorithm, every process gets executed in a cyclic way. A certain time slice is defined in the system which is called time quantum. Each process present in the ready queue is assigned the CPU for that time quantum, if the execution of the process is completed during that time then the process will terminate else the process will go back to the ready queue and waits for the next turn to complete the execution.</p><br>

        </div>
    </div>
    <hr>

<!-- End page content -->
    </div>



</body>
</html>
{% endblock %}